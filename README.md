# mist-ap41-challenge-resolver

This is a C implementation of the SHA256 HMAC based challenge implemented on the mist AP41.

I based my work on https://github.com/neggles/mist-ap41 , all of this wouldn't be possible witouth it, please make sure to check it out!. It cointains all the info on how to acess the device's serial console, you don't need to even open the device.

From the device /etc/inittab file, we can see console_login attached to the console listining to the serial port:
```
# Put a getty on the serial port
console::respawn:/sbin/getty -l /bin/console_login -L console 0 vt100
```
At the console promt, console_login will present a base64 encoded SHA256 HMAC challenge, with an initial 'B'. If the setting developer=true is present in the uboot enviroment (uboot settings are stored on 24c64 eeprom). 

I reverse engineering the binary console_login and I plan to write a guide with all the painfull steps that I had to endure (I knew noting about ghidra or arm v7 elf structure), in case another poor soul encountres a similar problem in the future, but for now this is a quick overview of the developer challenge:

The challenge has the following structure:

D|5c-5b-35-2f-4f-b4|developer|16 bits random number

1. Type of challange, D (developer), A (answer)
2. Mac address, fields separated by '-'
3. Username, when developer=true in uboot enviroment, the user is always 'developer'
4. Random number, 16bits (0x10) random number, from device's /dev/urandom

console_login expects a base64 encoded answer with the following structure:

1. 16 bits random number (same as the challenge)
2. SHA256 HMAC digest of a specific message, with a key generated by another SHA256 HMAC digest using a 16 bit key stored at address 0x400 at the device's eeprom.

if the answer checks console_login execs /bin/login {username at promt}

# getting access to the uboot promt at boot

Depending on the status of the device, if we hit Ctrl+C at boot prompt we will be present with an intriguing: 
```
challenge: TODO
response: 
```
I had a quick look at the uboot binary with ghydra and I soon realized that reverse engeniring bare metal binaries is a lot more harder!, but I was lucky to noticed the following piece of pseudo-code in ghydra:
```
bool FUN_00014b9c(void)

{
  int iVar1;
  
  iVar1 = FUN_00012410(DAT_00014c08);
  if (iVar1 != 0) {
    return false;
  }
  iVar1 = FUN_00012410(DAT_00014c0c);
  if ((iVar1 != 0) && (iVar1 = FUN_00012410(DAT_00014c10), iVar1 == 0)) {
    FUN_00012a7c(DAT_00014c14);
    iVar1 = FUN_00012af0();
    FUN_00012a7c(DAT_00014c18);
    return iVar1 == 0x42; 
  }
  return true;
}
```
0x42 is the ascii character 'B', that combined with the glorious TODO string from uboot, got me thinking maybe just expects a 'B' as a response?. So guess what, it did :
```
challenge: TODO
response:B
aph> 
```

from the uboot cli we can obtain the eeprom key located at 0x400, and set the developer=true env
1. eeprom rd 0x400 0x10 
2. env set developer true
3. env save

After reboot , trying any user will show first a developer challange, if the check fails then console_binary will generate a challenge type A with a different structure. 

# compilation

dependences = libssl, libcrypto

make (debug)

# usage 

Usage: ./sha256_challenge [arguments]

Arguments:

  -F <eeprom_file> 24c64 eeprom dump from a mist AP-41
  
  -C <challenge_from_mist> base64 challenge, with or withouth an initial B character
  
  -K <16 bit key from a mist AP41> , format deadbeefdeadbeefdeadbeeefdeadbeef 
  
  -i show info
  
  -h Show this help message

  

-F or -K are mandatory arguments.
# example challenge
"BRHwwYS0yNi02ZC05ZS00MS0zMHxkZXZlbG9wZXJ8qrvM3e7/qqusra6vuru8vQ==" 

