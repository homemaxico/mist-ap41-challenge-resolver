# mist-ap41-challenge-resolver

This is a C implementation of the SHA256 HMAC based login challenge present on the mist AP41.

I based this work on https://github.com/neggles/mist-ap41 , all of this wouldn't be possible witouth it, please make sure to check it out!. It cointains all the info on how to acess the device's serial console, you don't need to even open the device.

From the device /etc/inittab file, we can see console_login attached to the the serial console:
```
# Put a getty on the serial port
console::respawn:/sbin/getty -l /bin/console_login -L console 0 vt100
```
At login, console_login will present a base64 encoded SHA256 HMAC challenge, with an initial 'B'. I reverse engineering the binary console_login and wrote a [guide](docs/guide/the-journey) with all the painfull steps that I had to endure (I knew noting about ghidra or arm v7 assambler), in case another poor soul encountres a similar problem in the future, but for now this is a quick overview of the challenge generated by the binary:

The challenge has the following structure:

{D,A}|0a-26-6d-9e-41-30|{user}|16 or 32 bits random number, depending on the type of challenge

1. Type of challenge, D (developer), A (answer)
2. Mac address, fields separated by '-'
3. Username, when the uboot env developer=true is set, the user is always 'developer'
4. Random number, 16bits (0x10) for type D, 32bits (0x20) for type A, from device's /dev/urandom

console_login expects a base64 encoded answer (for the developer type) with the following structure:

1. 16 bits random number (same as the challenge).
2. SHA256 HMAC digest of a specific message, with a key generated by another SHA256 HMAC digest. The last digest uses a 16 bit key stored in address 0x400 at the device's eeprom.

if the answer checks console_login execs /bin/login {username at prompt, not necessarily "developer"}

# getting access to the uboot promt at boot

There are 2 different uboot systems on the device, but only one of them greats us with the following intriguing text after hitting Ctrl+C at boot prompt: 
```
challenge: TODO
response: 
```
Depending on the status of the device (if the system is configured and in production), there's a different uboot code that will generate a real challenge, similar to the one that console_login does. Power cyclyng the device a few times, letting the system start to boot but not letting linux to fully load, will trigger a nand flash erase. On the next boot you should see the familiar TODO on the screen. 

I had a quick look at the uboot binary with ghydra and I soon realized that reverse engeniring bare metal binaries is a lot more complicated, but I was lucky to noticed the following piece of pseudo-code in ghydra:
```
bool FUN_00014b9c(void)

{
  int iVar1;
  
  iVar1 = FUN_00012410(DAT_00014c08);
  if (iVar1 != 0) {
    return false;
  }
  iVar1 = FUN_00012410(DAT_00014c0c);
  if ((iVar1 != 0) && (iVar1 = FUN_00012410(DAT_00014c10), iVar1 == 0)) {
    FUN_00012a7c(DAT_00014c14);
    iVar1 = FUN_00012af0();
    FUN_00012a7c(DAT_00014c18);
    return iVar1 == 0x42; // Could it be the magic character?  
  }
  return true;
}
```
0x42 is the ascii character 'B', that combined with the glorious TODO string from uboot, got me thinking maybe just expects a 'B' as a response?. So guess what, it did :
```
challenge: TODO
response:B
aph> 
```

Once we got access to the uboot cli, we need to dump the eeprom key located at 0x400 and set the env developer=true
1. eeprom rd {offset} {lenght} 
   ```
   aph> eeprom rd 0x400 0x10
        00000400: 6c 2a 8f a9 ee 10 15 45 0f b4 XX XX XX XX XX XX    l*.....E...00000
   ```
2.
   ```
   aph>set developer true
   ```
3.
   ```
   aph>saveenv
   ```

From the uboot cli we can dumo the whole eeprom for further analysis, witouth desoldering anything or opening the device:
```
aph> eeprom rd 0 0x800
```

After reboot , trying to login as any user will show first a developer challenge, if the check fails then console_binary will generate a challenge type A with a different structure. 

# compilation

dependences = libssl, libcrypto

make , make debug

make test

# usage 

Usage: ./sha256_challenge [arguments]

Arguments:

  -F <eeprom_file> 24c64 eeprom dump from a mist AP-41

  -C <challenge_from_mist> base64 challenge, with or withouth an initial B character

  -K <16 bit key from a mist AP41> , format deadbeefdeadbeefdeadbeefdeadbeef 

  -G <mac address> generate a mist41 developer challenge for a given mac

  -R <16 bits random number> for challenge generation, format aabbccddeeffaaabacadaeafbabbbcbd

  -h Show this help message

  -i show info


-F or -K are mandatory arguments. if -R is not given the program will generate a random number.

# example challenge

```
./sha256_challenge -C BRHwwYS0yNi02ZC05ZS00MS0zMHxkZXZlbG9wZXJ8qrvM3e7/qqusra6vuru8vQAA -K deadbeefdeadbeefdeadbeefdeadbeef -i
```

```
Mac address: 0a-26-6d-9e-41-30
Challenge answer: Cm7nkp2X4cMfKuw00a-26-6d-9e-41-30fqxWAIytIQt26vkU
Random number from mist: aabbccddeeffaaabacadaeafbabbbcbd
------------------------
Developer Answer: BqrvM3e7/qqusra6vuru8vVE9SXcLIGETiUhSoyd14GI8m0DnSCCP0I4qdk4jxZ2r
```

